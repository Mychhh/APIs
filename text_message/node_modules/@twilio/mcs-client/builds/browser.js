/*
@license
Copyright (c) 2018, Twilio, Inc.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

*/
'use strict';

var global =
  typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : typeof window !== "undefined"
    ? window
    : {};

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
require('core-js/modules/es.promise.js');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/es.map.js');
require('core-js/modules/web.dom-collections.iterator.js');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
require('core-js/modules/web.dom-collections.for-each.js');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
require('core-js/modules/es.array.from.js');
var log$2 = require('loglevel');
require('core-js/modules/es.string.starts-with.js');
require('core-js/modules/es.array.reduce.js');
require('core-js/modules/es.regexp.exec.js');
require('core-js/modules/es.string.split.js');
require('core-js/modules/es.string.replace.js');
require('core-js/modules/es.json.stringify.js');
require('core-js/modules/es.object.assign.js');
require('core-js/modules/web.url.js');
require('core-js/modules/web.url-search-params.js');
var operationRetrier = require('@twilio/operation-retrier');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var log__namespace = /*#__PURE__*/_interopNamespace(log$2);

var rngBrowser = {exports: {}};

// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.

var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  rngBrowser.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  rngBrowser.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid$2(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}

var bytesToUuid_1 = bytesToUuid$2;

var rng$1 = rngBrowser.exports;
var bytesToUuid$1 = bytesToUuid_1; // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1$1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = rng$1();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid$1(b);
}

var v1_1 = v1$1;

var rng = rngBrowser.exports;
var bytesToUuid = bytesToUuid_1;

function v4$1(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

var v4_1 = v4$1;

var v1 = v1_1;
var v4 = v4_1;
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
var uuid_1 = uuid;

/**
 * Cancellable promise. Extends the functionality of the native Promise to include the cancel method.
 *
 * Example:
 *
 * ```ts
 *
 * const cancellableFetchPromise = new CancellablePromise(async (resolve, reject, onCancel) => {
 *     const request = fetch("https://example.com/");
 *
 *     onCancel(() => request.cancel());
 *
 *     try {
 *         const response = await request;
 *         resolve(response);
 *     } catch (err) {
 *         reject(err);
 *     }
 * });
 *
 * cancellableFetchPromise.cancel();
 * ```
 */

class CancellablePromise extends Promise {
  /**
   * Creates a new CancellablePromise.
   * @param executor A callback used to initialize the promise. This callback is passed three arguments:
   * a resolve callback used to resolve the promise with a value or the result of another promise,
   * a reject callback used to reject the promise with a provided reason or error,
   * and an onCancel callback used to define behavior of cancellation.
   */
  constructor(executor) {
    var outerId = uuid_1.v4();
    var outerRejectPromise;
    super((resolve, reject) => {
      outerRejectPromise = reject;
      return executor(value => {
        CancellablePromise.cancellationMap.delete(outerId);
        resolve(value);
      }, reason => {
        CancellablePromise.cancellationMap.delete(outerId);
        reject(reason);
      }, cancellationFunction => {
        CancellablePromise.cancellationMap.set(outerId, cancellationFunction);
      });
    });
    this.id = outerId;
    this.rejectPromise = outerRejectPromise;
  }
  /**
   * Cancels the promise and invokes the cancellation callback if it was defined during instantiation. Cancellation will result in the promise being rejected.
   */


  cancel() {
    var onCancel = CancellablePromise.cancellationMap.get(this.id);
    onCancel === null || onCancel === void 0 ? void 0 : onCancel();

    if (this.rejectPromise) {
      this.catch(() => void 0);
      this.rejectPromise(new Error("Promise was cancelled"));
    }

    return this;
  }

}

_defineProperty__default["default"](CancellablePromise, "cancellationMap", new Map());

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function prepareLine(prefix, args) {
  return ["".concat(new Date().toISOString(), " MCS Client ").concat(prefix, ":")].concat(Array.from(args));
}

class Logger {
  constructor(prefix) {
    _defineProperty__default["default"](this, "prefix", "");

    this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0 ? prefix + " " : "";
  }

  static scope(prefix) {
    return new Logger(prefix);
  }

  setLevel(level) {
    log__namespace.setLevel(level);
  }

  static setLevel(level) {
    log__namespace.setLevel(level);
  }
  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */


  trace() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    log__namespace.trace.apply(null, prepareLine(this.prefix + "T", args));
  }

  debug() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    log__namespace.debug.apply(null, prepareLine(this.prefix + "D", args));
  }

  info() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    log__namespace.info.apply(null, prepareLine(this.prefix + "I", args));
  }

  warn() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    log__namespace.warn.apply(null, prepareLine(this.prefix + "W", args));
  }

  error() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    log__namespace.error.apply(null, prepareLine(this.prefix + "E", args));
  }

  static trace() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    log__namespace.trace.apply(null, prepareLine("T", args));
  }

  static debug() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    log__namespace.debug.apply(null, prepareLine("D", args));
  }

  static info() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }

    log__namespace.info.apply(null, prepareLine("I", args));
  }

  static warn() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    log__namespace.warn.apply(null, prepareLine("W", args));
  }

  static error() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }

    log__namespace.error.apply(null, prepareLine("E", args));
  }

}

var MINIMUM_RETRY_DELAY = 1000;
var MAXIMUM_RETRY_DELAY = 4000;
var MAXIMUM_ATTEMPTS_COUNT = 3;
var RETRY_WHEN_THROTTLED = true;

var regionalMcsHost = region => "https://mcs.".concat(region !== null && region !== void 0 ? region : "us1", ".twilio.com");

var isFullUrl = url => url.startsWith("http");

var fullUrl = (partUrl, region) => "".concat(!isFullUrl(partUrl) ? regionalMcsHost(region) : "").concat(partUrl);

class Configuration {
  constructor(token, baseUrl, baseSetUrl, options) {
    var _ref, _options$MCS, _ref2, _constructorOptions$r, _constructorOptions$r2, _constructorOptions$b;

    var constructorOptions = (_ref = (_options$MCS = options.MCS) !== null && _options$MCS !== void 0 ? _options$MCS : options) !== null && _ref !== void 0 ? _ref : {};
    this.region = (_ref2 = (_constructorOptions$r = constructorOptions.region) !== null && _constructorOptions$r !== void 0 ? _constructorOptions$r : options.region) !== null && _ref2 !== void 0 ? _ref2 : 'us1';
    this.mediaUrl = fullUrl(baseUrl, this.region);
    this.mediaSetUrl = baseSetUrl ? fullUrl(baseSetUrl) : "".concat(this.mediaUrl, "Set");
    this.token = token;
    this.retryWhenThrottledOverride = (_constructorOptions$r2 = constructorOptions.retryWhenThrottledOverride) !== null && _constructorOptions$r2 !== void 0 ? _constructorOptions$r2 : RETRY_WHEN_THROTTLED;
    this.backoffConfigOverride = (_constructorOptions$b = constructorOptions.backoffConfigOverride) !== null && _constructorOptions$b !== void 0 ? _constructorOptions$b : Configuration.backoffConfigDefault;
  }

  static get backoffConfigDefault() {
    return {
      min: MINIMUM_RETRY_DELAY,
      max: MAXIMUM_RETRY_DELAY,
      maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT
    };
  }

  static get retryWhenThrottledDefault() {
    return RETRY_WHEN_THROTTLED;
  }

  updateToken(token) {
    this.token = token;
  }

}

/**
 * @classdesc A Media represents a metadata information for the media upload
 * @property {String} sid - The server-assigned unique identifier for Media
 * @property {String} serviceSid - Service instance id which Media belongs/uploaded to
 * @property {Date} dateCreated - When the Media was created
 * @property {Date} dateUpdated - When the Media was updated
 * @property {Number} size - Size of media, bytes
 * @property {String} contentType - content type of media
 * @property {String} fileName - file name, if present, null otherwise
 * @property {MediaCategory} category - attachment category
 */

class Media {
  constructor(config, network, data) {
    this.config = config;
    this.network = network;

    this._update(data);
  }

  get sid() {
    return this.state.sid;
  }

  get serviceSid() {
    return this.state.serviceSid;
  }

  get dateCreated() {
    return this.state.dateCreated;
  }

  get dateUpdated() {
    return this.state.dateUpdated;
  }

  get contentType() {
    return this.state.contentType;
  }

  get size() {
    return this.state.size;
  }
  /** @deprecated Use filename instead */


  get fileName() {
    return this.state.filename;
  }

  get filename() {
    return this.state.filename;
  }

  get category() {
    return this.state.category;
  }
  /**
   * Returns direct content URL to uploaded binary. This URL will expire after some time.
   * This function gets a new URL every time, preventing it from expiring but putting additional load on backend.
   * See getCachedContentUrl() for a function that reduces the amount of network requests.
   *
   * It is reasonable to build your own refresh logic upon these two functions: as soon as URL returned
   * by getCachedContentUrl() returns 40x status you should call getContentUrl() to refresh it.
   */


  getContentUrl() {
    var _this = this;

    return new CancellablePromise( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(resolve, reject, onCancel) {
        var request, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                request = _this.network.get("".concat(_this.config.mediaUrl, "/").concat(_this.sid));
                onCancel(() => request.cancel());
                _context.prev = 2;
                _context.next = 5;
                return request;

              case 5:
                response = _context.sent;

                _this._update(response.body);

                resolve(_this.state.contentDirectUrl);
                _context.next = 13;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](2);
                reject(_context.t0);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[2, 10]]);
      }));

      return function (_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      };
    }());
  }

  _update(data) {
    var _data$links$content_d, _data$filename, _data$category, _data$is_multipart_up;

    this.state = {
      sid: data.sid,
      serviceSid: data.service_sid,
      channelSid: data.channel_sid,
      messageSid: data.message_sid,
      dateCreated: data.date_created ? new Date(data.date_created) : null,
      dateUploadUpdated: data.date_upload_updated ? new Date(data.date_upload_updated) : null,
      dateUpdated: data.date_updated ? new Date(data.date_updated) : null,
      size: data.size,
      contentType: data.content_type,
      author: data.author,
      url: data.url,
      contentUrl: data.links.content,
      contentDirectUrl: (_data$links$content_d = data.links.content_direct_temporary) !== null && _data$links$content_d !== void 0 ? _data$links$content_d : null,
      filename: (_data$filename = data.filename) !== null && _data$filename !== void 0 ? _data$filename : null,
      category: (_data$category = data.category) !== null && _data$category !== void 0 ? _data$category : "media",
      isMultipartUpstream: (_data$is_multipart_up = data.is_multipart_upstream) !== null && _data$is_multipart_up !== void 0 ? _data$is_multipart_up : false
    };
  }

}

class TransportError extends Error {
  constructor(message, code, body, status, headers) {
    super(message);
    this.code = code;
    this.body = body;
    this.status = status;
    this.headers = headers;
  }

}

var XHR = global["XMLHttpRequest"] || {};

function parseResponseHeaders(headerString) {
  if (!headerString) {
    return {};
  }

  return headerString.split("\r\n").map(el => el.split(": ")).filter(el => el.length === 2 && el[1].length > 0).reduce((prev, curr) => {
    prev[curr[0]] = curr[1];
    return prev;
  }, {});
}

function extractBody(xhr) {
  var contentType = xhr.getResponseHeader("Content-Type");

  if (!contentType || contentType.indexOf("application/json") !== 0 || xhr.responseText.length === 0) {
    return xhr.responseText;
  }

  try {
    return JSON.parse(xhr.responseText);
  } catch (e) {
    return xhr.responseText;
  }
}
/**
 * Provides generic network interface
 */


class Transport {
  static request(method, url, headers, body) {
    return new CancellablePromise((resolve, reject, onCancel) => {
      var xhr = new XHR();
      var isCancelled = false;
      onCancel(() => {
        xhr.abort();
        isCancelled = true;
      });
      xhr.open(method, url, true);

      xhr.onreadystatechange = function onreadystatechange() {
        if (xhr.readyState !== 4 || isCancelled) {
          return;
        }

        var responseHeaders = parseResponseHeaders(xhr.getAllResponseHeaders());
        var body = extractBody(xhr);

        if (200 <= xhr.status && xhr.status < 300) {
          resolve({
            status: xhr.status,
            headers: responseHeaders,
            body
          });
        } else {
          var _xhr$statusText;

          var status = (_xhr$statusText = xhr.statusText) !== null && _xhr$statusText !== void 0 ? _xhr$statusText : "NONE";
          var bodyRepresentation;

          if (typeof body === "string") {
            if (body && body.split("\n", 2).length === 1) bodyRepresentation = body;else {
              var _body$replace$split$f;

              // TODO: RTDSDK-3716: investigate why body is HTML string
              var errorInfo = (_body$replace$split$f = body.replace(/<.*?>/g, "").split(/\r\n/g).filter(str => str.length)[0]) === null || _body$replace$split$f === void 0 ? void 0 : _body$replace$split$f.split(" ");
              bodyRepresentation = (errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.length) > 2 ? errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.slice(1).join(" ") : "";
            }
          } else {
            bodyRepresentation = JSON.stringify(body);
          }

          var message = "".concat(xhr.status, ": [").concat(status, "] ").concat(bodyRepresentation);
          reject(new TransportError(message, xhr.status, body, status, responseHeaders));
        }
      };

      for (var headerName in headers) {
        xhr.setRequestHeader(headerName, headers[headerName]);

        if (headerName === "Content-Type" && headers[headerName] === "application/json") {
          body = JSON.stringify(body);
        }
      }

      xhr.send(body);
    });
  }
  /**
   * Make a GET request by given URL
   */


  get(url, headers) {
    return Transport.request("GET", url, headers);
  }
  /**
   * Make a POST request by given URL
   */


  post(url, headers, body) {
    return Transport.request("POST", url, headers, body);
  }

}

var log$1 = Logger.scope("Network");

class Network {
  constructor(config, transport) {
    this.config = config;
    this.transport = transport;
  }

  backoffConfig() {
    return Object.assign(Configuration.backoffConfigDefault, this.config.backoffConfigOverride);
  }

  retryWhenThrottled() {
    var _ref, _this$config$retryWhe;

    return (_ref = (_this$config$retryWhe = this.config.retryWhenThrottledOverride) !== null && _this$config$retryWhe !== void 0 ? _this$config$retryWhe : Configuration.retryWhenThrottledDefault) !== null && _ref !== void 0 ? _ref : false;
  }

  executeWithRetry(request, retryWhenThrottled) {
    var _this = this;

    return new CancellablePromise( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(resolve, reject, onCancel) {
        var retrier, codesToRetryOn;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                retrier = new operationRetrier.Retrier(_this.backoffConfig());
                codesToRetryOn = [502, 503, 504];

                if (retryWhenThrottled) {
                  codesToRetryOn.push(429);
                }

                onCancel(() => {
                  retrier.cancel();
                  retrier.removeAllListeners();
                });
                retrier.on("attempt", /*#__PURE__*/_asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
                  var requestPromise, result;
                  return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          requestPromise = request();
                          onCancel(() => {
                            requestPromise.cancel();
                            retrier.cancel();
                            retrier.removeAllListeners();
                          });
                          _context.next = 5;
                          return requestPromise;

                        case 5:
                          result = _context.sent;
                          retrier.succeeded(result);
                          _context.next = 12;
                          break;

                        case 9:
                          _context.prev = 9;
                          _context.t0 = _context["catch"](0);

                          if (codesToRetryOn.indexOf(_context.t0.status) > -1) {
                            retrier.failed(_context.t0);
                          } else if (_context.t0.message === "Twilsock disconnected") {
                            // Ugly hack. We must make a proper exceptions for twilsock
                            retrier.failed(_context.t0);
                          } else {
                            // Fatal error
                            retrier.removeAllListeners();
                            retrier.cancel();
                            reject(_context.t0);
                          }

                        case 12:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 9]]);
                })));
                retrier.on("succeeded", result => {
                  resolve(result);
                });
                retrier.on("cancelled", err => reject(err));
                retrier.on("failed", err => reject(err));
                retrier.start();

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x, _x2, _x3) {
        return _ref2.apply(this, arguments);
      };
    }());
  }

  get(url) {
    var _this2 = this;

    return new CancellablePromise( /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(resolve, reject, onCancel) {
        var headers, request, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                headers = {
                  "X-Twilio-Token": _this2.config.token
                };
                request = _this2.executeWithRetry(() => _this2.transport.get(url, headers), _this2.retryWhenThrottled());
                log$1.trace("sending GET request to ", url, " headers ", headers);
                onCancel(() => request.cancel());
                _context3.prev = 4;
                _context3.next = 7;
                return request;

              case 7:
                response = _context3.sent;
                log$1.trace("response", response);
                resolve(response);
                _context3.next = 16;
                break;

              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](4);
                log$1.debug("get() error ".concat(_context3.t0));
                reject(_context3.t0);

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[4, 12]]);
      }));

      return function (_x4, _x5, _x6) {
        return _ref4.apply(this, arguments);
      };
    }());
  }

  post(url, category, media, contentType, filename) {
    var _this3 = this;

    var headers = {
      "X-Twilio-Token": this.config.token
    };

    if ((typeof FormData === "undefined" || !(media instanceof FormData)) && contentType) {
      Object.assign(headers, {
        "Content-Type": contentType
      });
    }

    var fullUrl = new URL(url);

    if (category) {
      fullUrl.searchParams.append("Category", category);
    }

    if (filename) {
      fullUrl.searchParams.append("Filename", filename);
    }

    return new CancellablePromise( /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4(resolve, reject, onCancel) {
        var request, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                request = _this3.transport.post(fullUrl.href, headers, media);
                onCancel(() => request.cancel());
                log$1.trace("sending POST request to ".concat(url, " with headers ").concat(headers));
                _context4.prev = 3;
                _context4.next = 6;
                return request;

              case 6:
                response = _context4.sent;
                _context4.next = 17;
                break;

              case 9:
                _context4.prev = 9;
                _context4.t0 = _context4["catch"](3);

                if (!(global["XMLHttpRequest"] === undefined && media instanceof FormData)) {
                  _context4.next = 14;
                  break;
                }

                reject(new TypeError("Posting FormData supported only with browser engine's FormData"));
                return _context4.abrupt("return");

              case 14:
                log$1.debug("post() error ".concat(_context4.t0));
                reject(_context4.t0);
                return _context4.abrupt("return");

              case 17:
                log$1.trace("response", response);
                resolve(response);

              case 19:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[3, 9]]);
      }));

      return function (_x7, _x8, _x9) {
        return _ref5.apply(this, arguments);
      };
    }());
  }

}

var version = "0.6.1";

var _class;
var log = Logger.scope("");
/**
 * @classdesc A Client provides an interface for Media Content Service
 */

exports["default"] = (_class = class Client {
  // eslint-disable-next-line

  /**
   * Base URLs must be full URLs with host. If host is not provided it will be generated from a default configuration
   * template using options.region.
   *
   * @param {String} token - Access token
   * @param {String} baseUrl - Base URL for Media Content Service Media resource, i.e. /v1/Services/{serviceSid}/Media
   * @param {String} baseSetUrl - Base URL for Media Content Service MediaSet resource, i.e. /v1/Services/{serviceSid}/MediaSet
   * @param {Client#ClientOptions} [options] - Options to customize the Client
   */
  constructor(token, baseUrl, baseSetUrl) {
    var _this$options$logLeve, _this$options$transpo;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    this.options = options;
    this.options.logLevel = (_this$options$logLeve = this.options.logLevel) !== null && _this$options$logLeve !== void 0 ? _this$options$logLeve : "silent";
    this.config = new Configuration(token, baseUrl, baseSetUrl, this.options);
    log.setLevel(this.options.logLevel);
    this.options.transport = (_this$options$transpo = this.options.transport) !== null && _this$options$transpo !== void 0 ? _this$options$transpo : new Transport();
    this.transport = this.options.transport;
    this.network = new Network(this.config, this.transport);
  }
  /**
   * These options can be passed to Client constructor
   * @typedef {Object} Client#ClientOptions
   * @property {String} [logLevel='silent'] - The level of logging to enable. Valid options
   *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
   */

  /**
   * Update the token used for Client operations
   * @param {String} token - The JWT string of the new token
   * @returns {void}
   */


  updateToken(token) {
    log.info("updateToken");
    this.config.updateToken(token);
  }
  /**
   * Gets media from media service
   * @param {String} sid - Media's SID
   */


  get(sid) {
    var _this = this;

    return new CancellablePromise( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(resolve, reject, onCancel) {
        var request, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                request = _this.network.get("".concat(_this.config.mediaUrl, "/").concat(sid));
                onCancel(() => request.cancel());
                _context.prev = 2;
                _context.next = 5;
                return request;

              case 5:
                response = _context.sent;
                resolve(new Media(_this.config, _this.network, response.body));
                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](2);
                reject(_context.t0);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[2, 9]]);
      }));

      return function (_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      };
    }());
  }
  /**
   * Posts raw content to media service
   * @param {String} contentType - content type of media
   * @param {String|Buffer|Blob} media - content to post
   * @param {MediaCategory|null} category - category for the media
   */


  post(contentType, media, category, filename) {
    var _this2 = this;

    return new CancellablePromise( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(resolve, reject, onCancel) {
        var request, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                request = _this2.network.post(_this2.config.mediaUrl, category !== null && category !== void 0 ? category : "media", media, contentType, filename);
                onCancel(() => request.cancel());
                _context2.prev = 2;
                _context2.next = 5;
                return request;

              case 5:
                response = _context2.sent;
                resolve(new Media(_this2.config, _this2.network, response.body));
                _context2.next = 12;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](2);
                reject(_context2.t0);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 9]]);
      }));

      return function (_x4, _x5, _x6) {
        return _ref2.apply(this, arguments);
      };
    }());
  }
  /**
   * Posts FormData to media service. Can be used only with browser engine's FormData.
   * In non-browser FormData case the method will do promise reject with
   * new TypeError("Posting FormData supported only with browser engine's FormData")
   * @param {FormData} formData - form data to post
   * @param {MediaCategory|null} category - category for the media
   */


  postFormData(formData, category) {
    var _this3 = this;

    return new CancellablePromise( /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(resolve, reject, onCancel) {
        var request, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                request = _this3.network.post(_this3.config.mediaUrl, category !== null && category !== void 0 ? category : "media", formData);
                onCancel(() => request.cancel());
                _context3.prev = 2;
                _context3.next = 5;
                return request;

              case 5:
                response = _context3.sent;
                resolve(new Media(_this3.config, _this3.network, response.body));
                _context3.next = 12;
                break;

              case 9:
                _context3.prev = 9;
                _context3.t0 = _context3["catch"](2);
                reject(_context3.t0);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[2, 9]]);
      }));

      return function (_x7, _x8, _x9) {
        return _ref3.apply(this, arguments);
      };
    }());
  }
  /**
   * Retrieve information about multiple media SIDs at the same time.
   * @param mediaSids Array of Media SIDs to get information from.
   */


  mediaSetGet(mediaSids) {
    var _this4 = this;

    return new CancellablePromise( /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4(resolve, reject, onCancel) {
        var query, request, response, media;
        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                query = {
                  command: "get",
                  list: mediaSids.map(sid => ({
                    media_sid: sid
                  }))
                };
                request = _this4.network.post("".concat(_this4.config.mediaSetUrl), null, query, "application/json");
                onCancel(() => request.cancel());
                _context4.prev = 3;
                _context4.next = 6;
                return request;

              case 6:
                response = _context4.sent;
                media = response.body.map(item => {
                  if (item.code !== 200) {
                    reject("Failed to obtain detailed information about Media items (failed SID ".concat(item.media_record.sid, ")"));
                    return;
                  }

                  return new Media(_this4.config, _this4.network, item.media_record);
                });
                resolve(media);
                _context4.next = 14;
                break;

              case 11:
                _context4.prev = 11;
                _context4.t0 = _context4["catch"](3);
                reject(_context4.t0);

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[3, 11]]);
      }));

      return function (_x10, _x11, _x12) {
        return _ref4.apply(this, arguments);
      };
    }());
  }
  /**
   * Retrieve temporary URLs for a set of media SIDs.
   * @param mediaSids array of the media SIDs to get URLs from.
   */


  mediaSetGetContentUrls(mediaSids) {
    var _this5 = this;

    return new CancellablePromise( /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee5(resolve, reject, onCancel) {
        var query, request, response, urls;
        return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                query = {
                  command: "get",
                  list: mediaSids.map(sid => ({
                    media_sid: sid
                  }))
                };
                request = _this5.network.post("".concat(_this5.config.mediaSetUrl), null, query, "application/json");
                onCancel(() => request.cancel());
                _context5.prev = 3;
                _context5.next = 6;
                return request;

              case 6:
                response = _context5.sent;
                urls = new Map();
                response.body.forEach(item => {
                  if (item.code !== 200) {
                    reject("Failed to obtain detailed information about Media items (failed SID ".concat(item.media_record.sid, ")"));
                    return;
                  }

                  urls.set(item.media_record.sid, item.media_record.links.content_direct_temporary);
                });
                resolve(urls);
                _context5.next = 15;
                break;

              case 12:
                _context5.prev = 12;
                _context5.t0 = _context5["catch"](3);
                reject(_context5.t0);

              case 15:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[3, 12]]);
      }));

      return function (_x13, _x14, _x15) {
        return _ref5.apply(this, arguments);
      };
    }());
  }

}, _defineProperty__default["default"](_class, "version", version), _class);

__decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", void 0)], exports["default"].prototype, "updateToken", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", CancellablePromise)], exports["default"].prototype, "get", null);

exports["default"] = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.literal(null)], [declarativeTypeValidator.pureObject, "undefined"]), __metadata("design:paramtypes", [String, String, Object, Object])], exports["default"]); // Proper renames should happen in index.ts,

exports.CancellablePromise = CancellablePromise;
exports.Client = exports["default"];
exports.McsClient = exports["default"];
exports.McsMedia = Media;
exports.Media = Media;
//# sourceMappingURL=browser.js.map
